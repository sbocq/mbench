/*
* Copyright (C) 2013 Alcatel-Lucent.
*
* See the NOTICE file distributed with this work for additional
* information regarding copyright ownership.
* Licensed to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License. You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied. See the License for the
* specific language governing permissions and limitations
* under the License.
*/

package mbench
package benchmark

/**
 * This class represents columns whose values are computed during the execution of a benchmark.
 *
 * A column is typically created using one of the factory methods available in the companion object.
 * The value it computes for each input might use some state it computed during a previous input,
 * the current input passed to the test under evaluation, the static configuration parameter
 * `C` passed to the test (see [[mbench.benchmark.Config]]), the median time taken to execute
 * the test, and the coefficient of variation measured across several runs of the test.
 *
 * @tparam I the type of the input of the benchmark.
 * @tparam C the type of static configuration parameter expected by a column.
 * @tparam T the type of the values generated by a column.
 *
 * @param label   The label of the column
 * @param compute Function that computes the value of the column from the following parameters:
 *   - State:  the state of the benchmark, which is threaded through evaluations of consecutive inputs,
 *   - I:      the current input of the test,
 *   - C:      the value of a static configuration parameter,
 *   - Double: the median time taken by the test using the current input,
 *   - Double: the coefficient of variation.
 */
case class Column[-I, -C, +T](label: Label[T], compute: (State, I, C, Double, Double) => (State, T)) {

  /**
   * Update this column such that it supports extended configurations (see `extend`
   * method on [[mbench.benchmark.StaticConfig]]).
   *
   * @tparam D the extended configuration type.
   */
  def extend[D]: Column[I, (C, D), T] =
    Column(label, (state, i, p, time, cvar) => compute(state, i, p._1, time, cvar))

  /**
   * Compute the value of new column for an input parameter `i` using the value of
   * this column computed for the first input of a benchmark and the value of this
   * column computed for the current input.
   *
   * This can be used for example to compute the parallel speedup of a test
   * if `I` represents the number of threads and this column contains the
   * execution time.
   *
   * @param label the label of the new column.
   * @param f the compute function who takes the first value of this
   *           column as first argument and the current value of this column
   *           as a second argument.
   * @return the new column.
   */
  def usingFirstResult[U](label: Label[U], f: (T, T) => U): Column[I, C, U] = {
    val first = label.name + ".first"
    Column[I, C, U](label, (state, input, config, time, cvar) =>
      if (state.contains(first)) {
        val init = state(first).asInstanceOf[T]
        val (_, current) = compute(state, input, config, time, cvar)
        (state, f(init, current))
      } else {
        val (_, init) = compute(state, input, config, time, cvar)
        (state + ((first, init)), f(init, init))
      }
    )
  }

  /**
   * Create a column that measures the speedup by dividing the
   * current value and the initial value of this column.
   *
   * For example, if `I` represents the number of threads and this
   * column measures the throughput for a constant load, this method
   * will create a new column that computes the parallel speedup.
   *
   *  @return the label together with the new column that computes the speedup.
   */
  def speedupHigherIsBetter[A >: T](implicit ev: Numeric[A]): Column[I, C, Double] =
    usingFirstResult(Label[Double]("speedup"), (first, current) => ev.toDouble(current) / ev.toDouble(first))

  /**
   * Create a column that measures the speedup by dividing the
   * the initial value of this column with the current value.
   *
   * For example, if `I` represents the number of threads and this
   * column measures the time taken by a test for a constant load, this method
   * will create a new column that computes the parallel speedup.
   *
   *  @return the label together with the new column that computes the speedup.
   */
  def speedupLowerIsBetter[A >: T](implicit ev: Numeric[A]): Column[I, C, Double] =
    usingFirstResult(Label[Double]("speedup"), (first, current) => ev.toDouble(first) / ev.toDouble(current))

  /**
   * Create a column that computes its value by dividing each value in this column
   * with each values in another column.
   *
   * @param name  the name of the new column created
   * @param other the other column
   * @return the label of the new column together with that column
   */
  def per[J <: I, D <: C, A >: T, U](name: String, other: Column[J, D, U])(implicit ev1: Numeric[A], ev2: Numeric[U]): Column[J, D, Double] = {
    Column[J, D, Double](Label(name, label.per(other.label)), (state, input, config, time, cvar) => {
      val (_, num) = this.compute(state, input, config, time, cvar)
      val (_, den) = other.compute(state, input, config, time, cvar)
      (state, ev1.toDouble(num) / ev2.toDouble(den))
    })
  }

  /**
   * Create a column that computes the throughput of the quantity measured
   * by this column by dividing each value of this column with the execution
   * time a test for each input of a benchmark.
   *
   * @return a new column that computes the throughput of the quantity represented
   *         by this column.
   */
  def throughput[A >: T](implicit ev1: Numeric[A]): Column[I, C, Double] =
    this.per[I, C, A, Double]("throughput", Column.time)

}

/**
 * Factory method for columns.
 */
object Column {

  /**
   * Standard column for the input.
   */
  def input[I](label: Label[I]): Column[I, Any, I] =
    Column(label, (state, input, config, time, cvar) => (state, input))

  /**
   * Standard column for the time.
   */
  val time: Column[Any, Any, Double] =
    Column(Label.time, (state, input, config, time, cvar) => (state, time))

  /**
   * Standard column for the coefficient of variation.
   */
  val cvar: Column[Any, Any, Double] =
    Column(Label.cvar, (state, input, config, time, cvar) => (state, cvar))

  /**
   * A column that computes the speedup based on the timings.
   */
  def timeSpeedup: Column[Any, Any, Double] =
    Column.time.speedupLowerIsBetter

  /**
   * A column that computes the throughput by dividing input values with
   * the time measured for executing the test.
   *
   * @return a new column that computes the throughput from the values
   *  of the input.
   */
  def throughput[I](ilabel: Label[I])(implicit ev: Numeric[I]): Column[I, Any, Double] =
    Column[I, Double]("throughput", ilabel.perSeconds)((i, time) => ev.toDouble(i) / time)

  /**
   * Create a column that computes a value based on the input value of the test
   * and the time it took to execute.
   *
   * @tparam I the input type of the benchmark.
   * @tparam T the type of the values stored in the column.
   *
   * @param name the name of a label.
   * @param unit the unit of the label.
   * @param f a function that computes the value of the column based on the input and the time.
   *
   * @return a new column
   */
  def apply[I, T <: AnyVal: ClassTag](name: String, unit: String = "")(f: (I, Double) => T): Column[I, Any, T] =
    Column[I, Any, T](Label(name, unit), (state, input, config, time, cvar) => (state, f(input, time)))

  /**
   * Create a column that compute a value based on the state of the benchmark,
   * the input value to the test and the time the test took to execute.
   *
   * @tparam I the input type of the benchmark.
   * @param label a label.
   * @param f a function that computes the value of the column based on the state, the input, the time.
   *
   * @return a new column
   */
  def withState[I, T](label: Label[T], f: (State, I, Double) => (State, T)): Column[I, Any, T] =
    Column(label, (state, input, config, time, cvar) => f(state, input, time))

  /**
   * Create a column that compute a value based on the config of the benchmark,
   * the input value to the test and the time the test took to execute.
   *
   * @tparam C the config of the benchmark.
   * @tparam I the input type of the benchmark.
   * @param label a label.
   * @param f a function that computes the value of the column based on the config, the input, the time.
   *
   * @return a new column
   */
  def withConfig[I, C, T <: AnyVal: ClassTag](name: String, unit: String = "")(f: (I, C, Double) => T): Column[I, C, T] =
    Column(Label(name, unit), (state, input, config, time, cvar) => (state, f(input, config, time)))

  /**
   * A row function is a function that compute the value of a column given the
   * the state of the benchmark, an input, the time columnd and the variation.
   */
  private[benchmark]type MFunction[I, C] = (State, I, C, Double, Double) => (State, Vector[Any])

  /**
   * Create a function that computes the values of the columns defined by the end user.
   *
   * @param  columns the user defined columns of a benchmark.
   * @return the labels of the columns together with a row function that computes their values
   *         (time and variation columns are automatically included).
   */
  def toFunction[I, C](ilabel: Label[I], columns: Vector[Column[I, C, _]]): (Vector[Label[_]], MFunction[I, C]) = {
    val cols: Vector[Column[I, C, _]] = Column.input[I](ilabel) +: Column.time +: Column.cvar +: columns
    val labels = cols.map(_.label)
    val rowF = cols.foldLeft[MFunction[I, C]](
      (s, i, config, time, cvar) => (s, Vector())
    )((rowF, column) => ((s1, i, config, time, cvar) => {
        val (s2, values) = rowF(s1, i, config, time, cvar)
        val (s3, value) = column.compute(s2, i, config, time, cvar)
        (s3, values :+ value)
      }))
    (labels, rowF)
  }

  private[mbench] def toLabels(columns: Vector[Column[_, _, _]]): Vector[Label[_]] = columns.map(_.label)

  implicit def toLabel[S, I, T](column: Column[S, I, T]): Label[T] = column.label

}